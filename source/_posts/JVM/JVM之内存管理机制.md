---
title: JVM之内存管理机制
date: 2019-03-15
updated: 2019-03-15
tags:
- JVM
- 内存
categories: JVM
---


# 运行时内存区域划分
> Java源文件(`.java文件`)会被Java编译器编译为字节码文件(`.class文件`)，再由JVM中的类加载器去加载各个类的字节码文件，加载完成后交给JVM执行引擎执行。

在Java程序执行过程中，会动态地将内存划分为如下几大区域：

- 虚拟机栈
- 堆
- 方法区
- 程序计数器
- 本地方法栈



其中这些区域又可划分为两大类

- 由所有线程共享的区域
  
    方法区、堆、本地方法栈
- 线程私有的数据区

    虚拟机栈、程序计数器



## 程序计数器

- 是一块较小的内存
- 作用：当前线程所执行的字节码的行号指示器
- 通过改变这个计数器的值来选取下一条需要执行的字节码指令
- 为了线程切换后能恢复到正确的执行位置，因此每条线程都需要一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储
- 它的区域为“线程私有”的内存
- 此内存区域是唯一一个在Java虚拟机规范中没有规定任何**OutOfMemoryError**情况的区域

在Java的内存分配中有这么一段话：
> 如果线程正在执行的是一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是**Native**方法，这个计数器值为空。

上述这句话引入了一个问题：

我们知道，程序计数器用来存放字节码指令的地址；通过这个地址，虚拟机就能知道执行到哪里，下一步执行什么，但是调用`native`方法，值就变空了，那么机器不就直接崩溃了吗？

解释：当线程中调用native方法的时候，则重新启动一个新的线程，那么新的线程的计数器为空则不会影响当前线程的计数器，相互独立。而调用此方法的线程就会处于阻塞状态，直到另外一个线程执行结束才会恢复到运行状态


## 虚拟机栈

- 线程私有，声明周期与线程相同
- 方法在执行时会创建一个**栈帧**，每一个方法被调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程

>上面提到了栈帧，那么什么是栈帧呢
>解释：栈帧用来存储**局部变量表**、**操作栈**、**动态链接**、**方法出口**等信息。

### 局部变量表

- 存放编译期可知的各种**基本类型数据**(`boolean`、`byte`、`char`、`short`、`int`、`float`、`long`、`double`)、**对象引用**(reference类型)和**returnAddress类型**(指向了一条字节码指令的地址)
- 除了64位的`long`和`double`类型的数据会占用2个局部变量空间，其余的数据类型只占用1个
- 当进入一个方法，这个方法需要在栈帧中分配多大局部变量空间时完全确定的，方法在运行期间不会改变局部变量表的大小

### 栈异常

- 线程请求的的栈深度大于虚拟机所允许的深度，将抛出`StackOverflowError`异常
- 若虚拟机可动态扩展(当前大部分的Java虚拟机都可动态扩展，只不过Java虚拟机规范中也允许固定长度的虚拟机栈)，但扩展无法申请到足够内存时会抛出`StackOverflowError`异常
- 


## 本地方法栈

- 与虚拟机栈的作用类似
- 区别：虚拟机栈为虚拟机执行Java方法服务，而本地方法则为虚拟机使用到的Native方法服务
- Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一
- 本地方法栈也会抛出`StackOverflowError`和`OutOfMemoryError`异常


## Java堆

- 是Java虚拟机所管理的内存中最大的一块
- 被所有线程共享
- 所有的对象实例以及数组都要在堆上分配
- 现在的收集器基本都采用分代收集算法，所以Java堆还可以细分为：**新生代**和**老生代**
- 如果堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出**OutOfMemoryError**异常

## 方法区

- 所有线程共享的内存区域
- 存储已被虚拟机加载的类信息、常量、静态变量
- 垃圾收集在这个区域比较少出现
- 这个区域的内存回收目标主要对常良池的回收和对类型的卸载
- 当方法去无法满足内存分配需求时，将抛出**OutOfMemoryError**异常


## 运行时常量池

- 方法区的一部分
- Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译器存放的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中
- 除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中


# 对象访问

**主流访问方式有两种：**句柄和直接指针


- **句柄**
<br>使用句柄询问方式，Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址。而句柄中包含了对象的实例数据和类型数据各自的具体地址信息，如下图所示：

    ![](https://upload-images.jianshu.io/upload_images/2349677-238abede0d7116e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)
    
    >**优势：reference中存储的是稳定的句柄地址，在对象被移动时(垃圾收集时移动对象是非常普遍的行为)只会改变句柄中的实例数据指针，而reference本身不需要被修改**

- **直接指针**
<br>使用直接指针方式，Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference中直接存储的就是对象地址，如图所示：
    ![](https://upload-images.jianshu.io/upload_images/2349677-70fc70c77788ccc4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

    >**优势：速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本，而目前我们使用的虚拟机Sun HotSpot就是使用第二种方式进行对象访问的**
